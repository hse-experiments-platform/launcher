// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkDatasetStatus = `-- name: CheckDatasetStatus :one
select status::text = any ($2::text[])
from datasets
where id = $1
`

type CheckDatasetStatusParams struct {
	ID       int64
	Statuses []string
}

func (q *Queries) CheckDatasetStatus(ctx context.Context, arg CheckDatasetStatusParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDatasetStatus, arg.ID, arg.Statuses)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkLaunchStatus = `-- name: CheckLaunchStatus :one
select launch_status = any ($2::text[])
from launches
where id = $1
`

type CheckLaunchStatusParams struct {
	ID       int64
	Statuses []string
}

func (q *Queries) CheckLaunchStatus(ctx context.Context, arg CheckLaunchStatusParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkLaunchStatus, arg.ID, arg.Statuses)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkModelExists = `-- name: CheckModelExists :one
select class_name
from models
where id = $1
`

func (q *Queries) CheckModelExists(ctx context.Context, id int64) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, checkModelExists, id)
	var class_name pgtype.Text
	err := row.Scan(&class_name)
	return class_name, err
}

const createLaunch = `-- name: CreateLaunch :one
insert into launches (launch_type, user_id, name, description, launch_status, input)
values ($1, $2, $3, $4, $5, $6)
returning id
`

type CreateLaunchParams struct {
	LaunchType   string
	UserID       int64
	Name         string
	Description  string
	LaunchStatus string
	Input        []byte
}

func (q *Queries) CreateLaunch(ctx context.Context, arg CreateLaunchParams) (int64, error) {
	row := q.db.QueryRow(ctx, createLaunch,
		arg.LaunchType,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.LaunchStatus,
		arg.Input,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createTrainedModel = `-- name: CreateTrainedModel :one
insert into trained_models (name, description, base_model_id, train_dataset_id, launch_id, target_column)
values ($1, $2, $3, $4, $5, $6)
returning id
`

type CreateTrainedModelParams struct {
	Name           pgtype.Text
	Description    pgtype.Text
	BaseModelID    pgtype.Int8
	TrainDatasetID pgtype.Int8
	LaunchID       pgtype.Int8
	TargetColumn   pgtype.Text
}

func (q *Queries) CreateTrainedModel(ctx context.Context, arg CreateTrainedModelParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTrainedModel,
		arg.Name,
		arg.Description,
		arg.BaseModelID,
		arg.TrainDatasetID,
		arg.LaunchID,
		arg.TargetColumn,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const finishLaunch = `-- name: FinishLaunch :exec
update launches
set launch_status = $2,
    updated_at    = now(),
    finished_at   = now(),
    launch_error  = $3,
    output        = $4
where id = $1
`

type FinishLaunchParams struct {
	ID           int64
	LaunchStatus string
	LaunchError  pgtype.Text
	Output       []byte
}

func (q *Queries) FinishLaunch(ctx context.Context, arg FinishLaunchParams) error {
	_, err := q.db.Exec(ctx, finishLaunch,
		arg.ID,
		arg.LaunchStatus,
		arg.LaunchError,
		arg.Output,
	)
	return err
}

const getDatasetCreator = `-- name: GetDatasetCreator :one
select creator_id
from datasets
where id = $1
`

func (q *Queries) GetDatasetCreator(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getDatasetCreator, id)
	var creator_id int64
	err := row.Scan(&creator_id)
	return creator_id, err
}

const getLaunch = `-- name: GetLaunch :one
select id,
       name,
       description,
       launch_status,
       launch_error,
       launch_type,
       input,
       output
from launches
where id = $1
`

type GetLaunchRow struct {
	ID           int64
	Name         string
	Description  string
	LaunchStatus string
	LaunchError  pgtype.Text
	LaunchType   string
	Input        []byte
	Output       []byte
}

func (q *Queries) GetLaunch(ctx context.Context, id int64) (GetLaunchRow, error) {
	row := q.db.QueryRow(ctx, getLaunch, id)
	var i GetLaunchRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.LaunchStatus,
		&i.LaunchError,
		&i.LaunchType,
		&i.Input,
		&i.Output,
	)
	return i, err
}

const getLaunchType = `-- name: GetLaunchType :one
select launch_type
from launches
where id = $1
`

func (q *Queries) GetLaunchType(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getLaunchType, id)
	var launch_type string
	err := row.Scan(&launch_type)
	return launch_type, err
}

const getLaunches = `-- name: GetLaunches :many
select id, launch_type, user_id, name, description, created_at, updated_at, finished_at, launch_status, launch_error, input, output,
       count(1) over () as count
from launches
where name like '%' || $3 || '%'
  and (launch_type = $4 or $4 = '')
  and user_id = $5
order by created_at desc
limit $1 offset $2
`

type GetLaunchesParams struct {
	Limit      int64
	Offset     int64
	Name       pgtype.Text
	LaunchType string
	UserID     int64
}

type GetLaunchesRow struct {
	ID           int64
	LaunchType   string
	UserID       int64
	Name         string
	Description  string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	FinishedAt   pgtype.Timestamptz
	LaunchStatus string
	LaunchError  pgtype.Text
	Input        []byte
	Output       []byte
	Count        int64
}

func (q *Queries) GetLaunches(ctx context.Context, arg GetLaunchesParams) ([]GetLaunchesRow, error) {
	rows, err := q.db.Query(ctx, getLaunches,
		arg.Limit,
		arg.Offset,
		arg.Name,
		arg.LaunchType,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLaunchesRow
	for rows.Next() {
		var i GetLaunchesRow
		if err := rows.Scan(
			&i.ID,
			&i.LaunchType,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.LaunchStatus,
			&i.LaunchError,
			&i.Input,
			&i.Output,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelHyperparameters = `-- name: GetModelHyperparameters :many
select h.id,
       h.name,
       h.description,
       h.type,
       h.default_value
from models m
         join hyperparameters h on m.id = h.model_id
where m.id = $1
`

type GetModelHyperparametersRow struct {
	ID           int64
	Name         string
	Description  string
	Type         string
	DefaultValue string
}

func (q *Queries) GetModelHyperparameters(ctx context.Context, id int64) ([]GetModelHyperparametersRow, error) {
	rows, err := q.db.Query(ctx, getModelHyperparameters, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModelHyperparametersRow
	for rows.Next() {
		var i GetModelHyperparametersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Type,
			&i.DefaultValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelMetrics = `-- name: GetModelMetrics :many
select m2.metric_name
from models m
         join metrics m2 on m.id = m2.model_id
where m.id = $1
`

func (q *Queries) GetModelMetrics(ctx context.Context, id int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getModelMetrics, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var metric_name string
		if err := rows.Scan(&metric_name); err != nil {
			return nil, err
		}
		items = append(items, metric_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainedModelIDByLaunchID = `-- name: GetTrainedModelIDByLaunchID :one
select id
from trained_models
where launch_id = $1
`

func (q *Queries) GetTrainedModelIDByLaunchID(ctx context.Context, launchID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, getTrainedModelIDByLaunchID, launchID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateLaunchStatus = `-- name: UpdateLaunchStatus :exec
update launches
set launch_status = $2,
    updated_at    = now()
where id = $1
`

type UpdateLaunchStatusParams struct {
	ID           int64
	LaunchStatus string
}

func (q *Queries) UpdateLaunchStatus(ctx context.Context, arg UpdateLaunchStatusParams) error {
	_, err := q.db.Exec(ctx, updateLaunchStatus, arg.ID, arg.LaunchStatus)
	return err
}
