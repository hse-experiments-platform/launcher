// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLaunch = `-- name: CreateLaunch :one
insert into launches (launch_type, user_id, name, description, launch_status)
values ($1, $2, $3, $4, $5)
returning id
`

type CreateLaunchParams struct {
	LaunchType   string
	UserID       int64
	Name         string
	Description  string
	LaunchStatus string
}

func (q *Queries) CreateLaunch(ctx context.Context, arg CreateLaunchParams) (int64, error) {
	row := q.db.QueryRow(ctx, createLaunch,
		arg.LaunchType,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.LaunchStatus,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const finishLaunch = `-- name: FinishLaunch :exec
update launches
set launch_status = $2,
    updated_at = now(),
    finished_at = now(),
    launch_error = $3
where id = $1
`

type FinishLaunchParams struct {
	ID           int64
	LaunchStatus string
	LaunchError  pgtype.Text
}

func (q *Queries) FinishLaunch(ctx context.Context, arg FinishLaunchParams) error {
	_, err := q.db.Exec(ctx, finishLaunch, arg.ID, arg.LaunchStatus, arg.LaunchError)
	return err
}

const getDatasetCreator = `-- name: GetDatasetCreator :one
select creator_id
from datasets
where id = $1
`

func (q *Queries) GetDatasetCreator(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getDatasetCreator, id)
	var creator_id int64
	err := row.Scan(&creator_id)
	return creator_id, err
}

const getLaunches = `-- name: GetLaunches :many


select id, launch_type, user_id, name, description, created_at, updated_at, finished_at, launch_status, launch_error,
       count(1) over () as count
from launches
where name like '%' || $3 || '%'
  and (launch_type = $4 or $4 = '')
  and user_id = $5
order by created_at desc
limit $1 offset $2
`

type GetLaunchesParams struct {
	Limit      int64
	Offset     int64
	Name       pgtype.Text
	LaunchType string
	UserID     int64
}

type GetLaunchesRow struct {
	ID           int64
	LaunchType   string
	UserID       int64
	Name         string
	Description  string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	FinishedAt   pgtype.Timestamptz
	LaunchStatus string
	LaunchError  pgtype.Text
	Count        int64
}

// launches schema
// create table if not exists launches
// (
//
//	id            bigint primary key generated by default as identity,
//	launch_type   text                     not null,
//	user_id       bigint                   not null references users (id),
//	name          text                     not null,
//	description   text                     not null,
//	created_at    timestamp with time zone not null default now(),
//	updated_at    timestamp with time zone not null default now(),
//	finished_at   timestamp with time zone,
//	launch_status text                     not null,
//	launch_error  text
//
// );
func (q *Queries) GetLaunches(ctx context.Context, arg GetLaunchesParams) ([]GetLaunchesRow, error) {
	rows, err := q.db.Query(ctx, getLaunches,
		arg.Limit,
		arg.Offset,
		arg.Name,
		arg.LaunchType,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLaunchesRow
	for rows.Next() {
		var i GetLaunchesRow
		if err := rows.Scan(
			&i.ID,
			&i.LaunchType,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.LaunchStatus,
			&i.LaunchError,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLaunchStatus = `-- name: UpdateLaunchStatus :exec
update launches
set launch_status = $2,
    updated_at = now()
where id = $1
`

type UpdateLaunchStatusParams struct {
	ID           int64
	LaunchStatus string
}

func (q *Queries) UpdateLaunchStatus(ctx context.Context, arg UpdateLaunchStatusParams) error {
	_, err := q.db.Exec(ctx, updateLaunchStatus, arg.ID, arg.LaunchStatus)
	return err
}
